// import zk_dealer.leo;
import zk_deck_shuffle.leo;

// The 'zk_texas_holdem' program.
program zk_texas_holdem.aleo {

    struct Players {
        player0: address,
        player1: address,
        player2: address,
        player3: address,
        player4: address,
        player5: address,
        player6: address,
        player7: address,
        player8: address,
    }

    struct GameState {
        active: bool,
        players: Players,
        phi: u32,
        n: u32,
    }

    record Player {
        owner: address,
        table_address: address,
        phi: u32, // Eulier's Totient Used to setup e, d, deck_e, deck_d
        n: u32,  // Semi Prime N used to setup e, d, deck_e, deck_d
        e: u32, // Public SRA key
        d: u32, // Private SRA key
        deck_e: [[u32; 26]; 2], // Individual Card Public SRA keys
        deck_d: [[u32; 26]; 2], // Individual Card Private SRA keys
    }

    record Card {
        owner: address,
        card: u32,
    }

    record Deck {
        owner: address,
        cards: [[u32; 26]; 2],
    }

    mapping game_state_map: address => GameState; // Is there some better key than address?

    transition get_address(target_address: field) -> address {
        return target_address as address;
    }

    transition setup_game(players: Players, phi: u32, n: u32) -> Deck {
        let burn_address: address = 0field as address;
        let player0: address = players.player0;
        assert(player0 != burn_address);
        assert_eq(player0, self.caller);
        let player1: address = players.player1;
        let player2: address = players.player2;
        let player3: address = players.player3;
        let player4: address = players.player4;
        let player5: address = players.player5;
        let player6: address = players.player6;
        let player7: address = players.player7;
        let player8: address = players.player8;
        let p0: address = player0;
        let p1: address = burn_address;
        let p2: address = burn_address;
        let p3: address = burn_address;
        let p4: address = burn_address;
        let p5: address = burn_address;
        let p6: address = burn_address;
        let p7: address = burn_address;
        let p8: address = burn_address;
        if (player1 != burn_address) {
            p1 = player1;
        }
        if (player2 != burn_address) {
            p2 = player2;
        }
        if (player3 != burn_address) {
            p3 = player3;
        }
        if (player4 != burn_address) {
            p4 = player4;
        }
        if (player5 != burn_address) {
            p5 = player5;
        }
        if (player6 != burn_address) {
            p6 = player6;
        }
        if (player7 != burn_address) {
            p7 = player7;
        }
        if (player8 != burn_address) {
            p8 = player8;
        }

        let initiating_player: field = self.caller as field;
        let updated_players: Players = Players {
            player0: p0,
            player1: p1,
            player2: p2,
            player3: p3,
            player4: p4,
            player5: p5,
            player6: p6,
            player7: p7,
            player8: p8,
        };
        return Deck {
            owner: self.caller,
            cards: initial_deck(),
        } then finalize (self.caller, updated_players, phi, n);
    }

    finalize setup_game(caller: address, players: Players, phi: u32, n: u32) {
        assert_eq(players.player0, caller);
        let updated_game_state: GameState = GameState {
            active: true,
            players,
            phi,
            n,
        };
        Mapping::set(game_state_map, caller, updated_game_state);
    }

    // e is the public SRA key generated by client, d is the private SRA key generated by client
    transition join_game(table_address: address, e: u32, d: u32, phi: u32, n: u32) -> Player {
        return Player {
            owner: self.caller,
            table_address,
            phi,
            n,
            e,
            d,
            deck_e: empty_deck(),
            deck_d: empty_deck(),
        } then finalize (table_address, self.caller);
    }

    finalize join_game(table_address: address, caller: address) {
        let game_state: GameState = Mapping::get(game_state_map, table_address);
        assert(game_state.active);
        let players: Players = game_state.players;
        let listed: bool = false;
        let burn_address: address = 0field as address;
        if (players.player0 == caller) {
            listed = true;
        } 
        if (players.player1 == caller) {
            listed = true;
        }
        if (players.player2 == caller) {
            listed = true;
        }
        if (players.player3 == caller) {
            listed = true;
        }
        if (players.player4 == caller) {
            listed = true;
        }
        if (players.player5 == caller) {
            listed = true;
        }
        if (players.player6 == caller) {
            listed = true;
        }
        if (players.player7 == caller) {
            listed = true;
        }
        if (players.player8 == caller) {
            listed = true;
        }
        assert(listed);
    }

    transition shuffle_and_pass(player: Player, deck: Deck, s0: i8, s1: i8, s2: i8, s3: i8, next_player: address) -> (Player, Deck) {
        let encrypted_deck: [[u32; 26]; 2] = encrypt_deck(player.e, player.n, deck.cards);
        let shuffled_deck: [[u32; 26]; 2] = zk_deck_shuffle.leo/shuffle(encrypted_deck, s0, s1, s2, s3);
        
        return (Player {
            owner: player.owner,
            table_address: player.table_address,
            phi: player.phi,
            n: player.n,
            e: player.e,
            d: player.d,
            deck_e: player.deck_e,
            deck_d: player.deck_d,
        }, Deck {
            owner: next_player as address,
            cards: shuffled_deck,
        });
    }

    transition test_encrypt_decrypt(public m: u32, e: u32, d: u32, n: u32) -> (u32, u32) {
      let c: u32 = exp_by_squaring(m, e, n);
      let p: u32 = exp_by_squaring(c, d, n);
      return (c, p);
    }

    inline exp_by_squaring(base: u32, exp: u32, modulus: u32) -> u32 {
        let result: u64 = 1u64;
        let current_base: u64 = base as u64;
        let mod_u64: u64 = modulus as u64;

        for i: u32 in 0u32..32u32 {
            if (exp % 2u32 == 1u32) { 
                result = (result * current_base) % mod_u64;
            }
            current_base = (current_base * current_base) % mod_u64;
            exp >>= 1u32; // divide by two
        }

     return result as u32;
  }

    inline encrypt(message: u32, e: u32, n: u32) -> u32 {
        return exp_by_squaring(message, e, n);
    }

    inline decrypt(ciphertext: u32, d: u32, n: u32) -> u32 {
        return exp_by_squaring(ciphertext, d, n);
    }

    inline initial_deck() -> [[u32; 26]; 2] {
        return [[63u32, 62u32, 61u32, 60u32, 59u32, 58u32, 57u32, 56u32, 55u32, 54u32, 53u32, 52u32, 51u32,
                 50u32, 49u32, 48u32, 47u32, 46u32, 45u32, 44u32, 43u32, 42u32, 41u32, 40u32, 39u32, 38u32], 
                [37u32, 36u32, 35u32, 34u32, 33u32, 32u32, 31u32, 30u32, 29u32, 28u32, 27u32, 26u32, 25u32,
                 24u32, 23u32, 22u32, 21u32, 20u32, 19u32, 18u32, 17u32, 16u32, 15u32, 14u32, 13u32, 12u32]];
    }

    inline empty_deck() -> [[u32; 26]; 2] {
        return [[0u32, 0u32, 0u32, 0u32, 0u32, 0u32,0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32,
                 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32], 
                [0u32, 0u32, 0u32, 0u32, 0u32, 0u32,0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32,
                 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32]];
    }

    function encrypt_deck(e: u32, n: u32, deck: [[u32; 26]; 2]) -> [[u32; 26]; 2] {
        let bottom_half: [u32; 26] = deck[0u8];
        let top_half: [u32; 26] = deck[1u8];
        let c0: u32 = bottom_half[0u8] as u32;
        let c1: u32 = bottom_half[1u8] as u32;
        let c2: u32 = bottom_half[2u8] as u32;
        let c3: u32 = bottom_half[3u8] as u32;
        let c4: u32 = bottom_half[4u8] as u32;
        let c5: u32 = bottom_half[5u8] as u32;
        let c6: u32 = bottom_half[6u8] as u32;
        let c7: u32 = bottom_half[7u8] as u32;
        let c8: u32 = bottom_half[8u8] as u32;
        let c9: u32 = bottom_half[9u8] as u32;
        let c10: u32 = bottom_half[10u8] as u32;
        let c11: u32 = bottom_half[11u8] as u32;
        let c12: u32 = bottom_half[12u8] as u32;
        let c13: u32 = bottom_half[13u8] as u32;
        let c14: u32 = bottom_half[14u8] as u32;
        let c15: u32 = bottom_half[15u8] as u32;
        let c16: u32 = bottom_half[16u8] as u32;
        let c17: u32 = bottom_half[17u8] as u32;
        let c18: u32 = bottom_half[18u8] as u32;
        let c19: u32 = bottom_half[19u8] as u32;
        let c20: u32 = bottom_half[20u8] as u32;
        let c21: u32 = bottom_half[21u8] as u32;
        let c22: u32 = bottom_half[22u8] as u32;
        let c23: u32 = bottom_half[23u8] as u32;
        let c24: u32 = bottom_half[24u8] as u32;
        let c25: u32 = bottom_half[25u8] as u32;
        let c26: u32 = top_half[0u8] as u32;
        let c27: u32 = top_half[1u8] as u32;
        let c28: u32 = top_half[2u8] as u32;
        let c29: u32 = top_half[3u8] as u32;
        let c30: u32 = top_half[4u8] as u32;
        let c31: u32 = top_half[5u8] as u32;
        let c32: u32 = top_half[6u8] as u32;
        let c33: u32 = top_half[7u8] as u32;
        let c34: u32 = top_half[8u8] as u32;
        let c35: u32 = top_half[9u8] as u32;
        let c36: u32 = top_half[10u8] as u32;
        let c37: u32 = top_half[11u8] as u32;
        let c38: u32 = top_half[12u8] as u32;
        let c39: u32 = top_half[13u8] as u32;
        let c40: u32 = top_half[14u8] as u32;
        let c41: u32 = top_half[15u8] as u32;
        let c42: u32 = top_half[16u8] as u32;
        let c43: u32 = top_half[17u8] as u32;
        let c44: u32 = top_half[18u8] as u32;
        let c45: u32 = top_half[19u8] as u32;
        let c46: u32 = top_half[20u8] as u32;
        let c47: u32 = top_half[21u8] as u32;
        let c48: u32 = top_half[22u8] as u32;
        let c49: u32 = top_half[23u8] as u32;
        let c50: u32 = top_half[24u8] as u32;
        let c51: u32 = top_half[25u8] as u32;
        let t0: u32 = encrypt(c0, e, n);
        let t1: u32 = encrypt(c1, e, n);
        let t2: u32 = encrypt(c2, e, n);
        let t3: u32 = encrypt(c3, e, n);
        let t4: u32 = encrypt(c4, e, n);
        let t5: u32 = encrypt(c5, e, n);
        let t6: u32 = encrypt(c6, e, n);
        let t7: u32 = encrypt(c7, e, n);
        let t8: u32 = encrypt(c8, e, n);
        let t9: u32 = encrypt(c9, e, n);
        let t10: u32 = encrypt(c10, e, n);
        let t11: u32 = encrypt(c11, e, n);
        let t12: u32 = encrypt(c12, e, n);
        let t13: u32 = encrypt(c13, e, n);
        let t14: u32 = encrypt(c14, e, n);
        let t15: u32 = encrypt(c15, e, n);
        let t16: u32 = encrypt(c16, e, n);
        let t17: u32 = encrypt(c17, e, n);
        let t18: u32 = encrypt(c18, e, n);
        let t19: u32 = encrypt(c19, e, n);
        let t20: u32 = encrypt(c20, e, n);
        let t21: u32 = encrypt(c21, e, n);
        let t22: u32 = encrypt(c22, e, n);
        let t23: u32 = encrypt(c23, e, n);
        let t24: u32 = encrypt(c24, e, n);
        let t25: u32 = encrypt(c25, e, n);
        let t26: u32 = encrypt(c26, e, n);
        let t27: u32 = encrypt(c27, e, n);
        let t28: u32 = encrypt(c28, e, n);
        let t29: u32 = encrypt(c29, e, n);
        let t30: u32 = encrypt(c30, e, n);
        let t31: u32 = encrypt(c31, e, n);
        let t32: u32 = encrypt(c32, e, n);
        let t33: u32 = encrypt(c33, e, n);
        let t34: u32 = encrypt(c34, e, n);
        let t35: u32 = encrypt(c35, e, n);
        let t36: u32 = encrypt(c36, e, n);
        let t37: u32 = encrypt(c37, e, n);
        let t38: u32 = encrypt(c38, e, n);
        let t39: u32 = encrypt(c39, e, n);
        let t40: u32 = encrypt(c40, e, n);
        let t41: u32 = encrypt(c41, e, n);
        let t42: u32 = encrypt(c42, e, n);
        let t43: u32 = encrypt(c43, e, n);
        let t44: u32 = encrypt(c44, e, n);
        let t45: u32 = encrypt(c45, e, n);
        let t46: u32 = encrypt(c46, e, n);
        let t47: u32 = encrypt(c47, e, n);
        let t48: u32 = encrypt(c48, e, n);
        let t49: u32 = encrypt(c49, e, n);
        let t50: u32 = encrypt(c50, e, n);
        let t51: u32 = encrypt(c51, e, n);
        return [[t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10,
                 t11, t12, t13, t14, t15, t16, t17, t18, t19, t20,
                 t21, t22, t23, t24, t25],
                [t26, t27, t28, t29, t30, t31, t32, t33, t34, t35,
                 t36, t37, t38, t39, t40, t41, t42, t43, t44, t45,
                 t46, t47, t48, t49, t50, t51]];
    }
}
