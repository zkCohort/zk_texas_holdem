import zk_sra_encryption_v0_0_2.aleo;
import zk_deck_shuffle_v0_0_1.aleo;

// The 'zk_texas_holdem' program.
program zk_texas_holdem.aleo {

    struct Players {
        player0: address,
        player1: address,
        player2: address,
        player3: address,
        player4: address,
        player5: address,
        player6: address,
        player7: address,
        player8: address,
    }

    struct GameState {
        active: bool,
        players: Players,
        phi: field,
        n: u128,
    }

    record Player {
        owner: address,
        table_address: address,
        phi: field, // Eulier's Totient Used to setup e, d, deck_e, deck_d
        n: u128,  // Semi Prime N used to setup e, d, deck_e, deck_d
        e: field, // Public SRA key
        d: field, // Private SRA key
        deck_e: [[field; 26]; 2], // Individual Card Public SRA keys
        deck_d: [[field; 26]; 2], // Individual Card Private SRA keys
    }

    record Card {
        owner: address,
        card: field,
    }

    record Deck {
        owner: address,
        cards: [[field; 26]; 2],
    }

    mapping game_state_map: address => GameState; // Is there some better key than address?

    transition setup_game(players: Players, phi: field, n: u128) -> Deck {
        const burn_address: address = aleo1qgqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqanmpl0;
        let player0: address = players.player0;
        assert(player0 != burn_address);
        assert_eq(player0, self.caller);
        let player1: address = players.player1;
        let player2: address = players.player2;
        let player3: address = players.player3;
        let player4: address = players.player4;
        let player5: address = players.player5;
        let player6: address = players.player6;
        let player7: address = players.player7;
        let player8: address = players.player8;
        let p0: address = player0;
        let p1: address = burn_address;
        let p2: address = burn_address;
        let p3: address = burn_address;
        let p4: address = burn_address;
        let p5: address = burn_address;
        let p6: address = burn_address;
        let p7: address = burn_address;
        let p8: address = burn_address;
        if (player1 != burn_address) {
            p1 = player1;
        }
        if (player2 != burn_address) {
            p2 = player2;
        }
        if (player3 != burn_address) {
            p3 = player3;
        }
        if (player4 != burn_address) {
            p4 = player4;
        }
        if (player5 != burn_address) {
            p5 = player5;
        }
        if (player6 != burn_address) {
            p6 = player6;
        }
        if (player7 != burn_address) {
            p7 = player7;
        }
        if (player8 != burn_address) {
            p8 = player8;
        }

        let initiating_player: u128 = self.caller as u128;
        let updated_players: Players = Players {
            player0: p0,
            player1: p1,
            player2: p2,
            player3: p3,
            player4: p4,
            player5: p5,
            player6: p6,
            player7: p7,
            player8: p8,
        };
        return Deck {
            owner: self.caller,
            cards: initial_deck(),
        } then finalize (self.caller, updated_players, phi, n);
    }

    finalize setup_game(caller: address, players: Players, phi: field, n: u128) {
        assert_eq(players.player0, caller);
        let updated_game_state: GameState = GameState {
            active: true,
            players,
            phi,
            n,
        };
        Mapping::set(game_state_map, caller, updated_game_state);
    }

    // e is the public SRA key generated by client, d is the private SRA key generated by client
    transition join_game(table_address: address, e: field, d: field, phi: field, n: u128) -> Player {
        return Player {
            owner: self.caller,
            table_address,
            phi,
            n,
            e,
            d,
            deck_e: empty_deck(),
            deck_d: empty_deck(),
        } then finalize (table_address, self.caller);
    }

    finalize join_game(table_address: address, caller: address) {
        let game_state: GameState = Mapping::get(game_state_map, table_address);
        assert(game_state.active);
        let players: Players = game_state.players;
        let listed: bool = false;
        const burn_address: address = aleo1qgqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqanmpl0;
        if (players.player0 == caller) {
            listed = true;
        } 
        if (players.player1 == caller) {
            listed = true;
        }
        if (players.player2 == caller) {
            listed = true;
        }
        if (players.player3 == caller) {
            listed = true;
        }
        if (players.player4 == caller) {
            listed = true;
        }
        if (players.player5 == caller) {
            listed = true;
        }
        if (players.player6 == caller) {
            listed = true;
        }
        if (players.player7 == caller) {
            listed = true;
        }
        if (players.player8 == caller) {
            listed = true;
        }
        assert(listed);
    }

    

    transition shuffle_and_pass(player: Player, deck: Deck, shuffles: [i8; 7], next_player: address) -> (Player, Deck) {
        let encrypted_deck: [[field; 26]; 2] = zk_sra_encryption_v0_0_2.aleo/encrypt_deck(player.e, player.n, deck.cards);
        let member_size: u16 = 128u16;
        for i: i8 in 0i8..7i8 {
            encrypted_deck = zk_deck_shuffle_v0_0_1.aleo/shuffle_deck(shuffles[i], member_size, encrypted_deck);
        }
        return (Player {
            owner: player.owner,
            table_address: player.table_address,
            phi: player.phi,
            n: player.n,
            e: player.e,
            d: player.d,
            deck_e: player.deck_e,
            deck_d: player.deck_d,
        }, Deck {
            owner: next_player as address,
            cards: encrypted_deck,
        }) then finalize (self.caller, player.table_address, next_player);
    }

    finalize shuffle_and_pass(player_address: address, table_address: address, next_player: address) {
        const burn_address: address = aleo1qgqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqanmpl0;
        let game_state: GameState = Mapping::get(game_state_map, table_address);
        assert(game_state.active);
        let players: Players = game_state.players;
        let count: u8 = 0u8;
        if players.player0 != burn_address {
            count += 1u8;
        }
        if players.player1 != burn_address {
            count += 1u8;
        }
        if players.player2 != burn_address {
            count += 1u8;
        }
        if players.player3 != burn_address {
            count += 1u8;
        }
        if players.player4 != burn_address {
            count += 1u8;
        }
        if players.player5 != burn_address {
            count += 1u8;
        }
        if players.player6 != burn_address {
            count += 1u8;
        }
        if players.player7 != burn_address {
            count += 1u8;
        }
        if players.player8 != burn_address {
            count += 1u8;
        }
        assert(count > 1u8);
        // TODO - Figure out how to get the next player
        // let hands: [address; 9] = [players.player0, players.player1, players.player2, players.player3, players.player4, players.player5, players.player6, players.player7, players.player8];
        // let test_player: address = hands[0u8];
        // for i: u8 in 0u8..9u8 {
        //     if i < count && hands[i] == player_address {
        //         // Next player is the player after the current player
        //         // If i == count - 1, then next player is the first player
        //         if i == count - 1u8 {
        //             test_player = hands[0u8];
        //             assert_eq(test_player, next_player);
        //         } else {
        //             test_player = hands[i + 1u8];
        //             assert_eq(test_player, next_player);
        //         }
        //     }
        // }
    }

    transition decrypt_encrypt_each_then_pass(player: Player, deck: Deck, deck_e: [[field; 26]; 2], deck_d: [[field; 26]; 2], next_player: address) -> (Player, Deck) {
        let e: field = player.e;
        let d: field = player.d;
        let n: u128 = player.n;
        let decrypted_deck: [[field; 26]; 2] = zk_sra_encryption_v0_0_2.aleo/decrypt_deck(d, n, deck.cards);
        let encrypted_deck: [[field; 26]; 2] = zk_sra_encryption_v0_0_2.aleo/encrypt_deck_per_card(deck_e, n, decrypted_deck);
        return (
            Player {
                owner: self.caller,
                table_address: player.table_address,
                phi: player.phi,
                n: player.n,
                e: player.e,
                d: player.d,
                deck_e: deck_e,
                deck_d: deck_d,
            },
            Deck {
                owner: next_player,
                cards: encrypted_deck,
            }) then finalize (self.caller, player.table_address, next_player);
    }

    finalize decrypt_encrypt_each_then_pass(player_address: address, table_address: address, next_player: address) {
        const burn_address: address = aleo1qgqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqanmpl0;
        let game_state: GameState = Mapping::get(game_state_map, table_address);
        assert(game_state.active);
        let players: Players = game_state.players;
        let count: u8 = 0u8;
        if players.player0 != burn_address {
            count += 1u8;
        }
        if players.player1 != burn_address {
            count += 1u8;
        }
        if players.player2 != burn_address {
            count += 1u8;
        }
        if players.player3 != burn_address {
            count += 1u8;
        }
        if players.player4 != burn_address {
            count += 1u8;
        }
        if players.player5 != burn_address {
            count += 1u8;
        }
        if players.player6 != burn_address {
            count += 1u8;
        }
        if players.player7 != burn_address {
            count += 1u8;
        }
        if players.player8 != burn_address {
            count += 1u8;
        }
        assert(count > 1u8);
        // TODO Validate next player is in the game
        // let hands: [address; 9] = [players.player0, players.player1, players.player2, players.player3, players.player4, players.player5, players.player6, players.player7, players.player8];
        // let test_player: address = hands[0u8];
        // for i: u8 in 0u8..9u8 {
        //     if i < count && hands[i] == player_address {
        //         // Next player is the player after the current player
        //         // If i == count - 1, then next player is the first player
        //         if i == count - 1u8 {
        //             test_player = hands[0u8];
        //             assert_eq(test_player, next_player);
        //         } else {
        //             test_player = hands[i + 1u8];
        //             assert_eq(test_player, next_player);
        //         }
        //     }
        // }
    }

    /// Deal Card to Player
    /// TODO - Figure out how to do this at scale.
    transition test_reveal_card(card: field, d1: field, d2: field, n: u128) -> Card {
        let cipher_intermediary: field = zk_sra_encryption_v0_0_2.aleo/sra_decrypt(card, d1, n);
        let message: field = zk_sra_encryption_v0_0_2.aleo/sra_decrypt(cipher_intermediary, d2, n);
        return Card {
            owner: self.caller,
            card: message
        };
    }

    /// Reveal Card to Player

    inline initial_deck() -> [[field; 26]; 2] {
        return [[63field, 62field, 61field, 60field, 59field, 58field, 57field, 56field, 55field, 54field, 53field, 52field, 51field,
                 50field, 49field, 48field, 47field, 46field, 45field, 44field, 43field, 42field, 41field, 40field, 39field, 38field], 
                [37field, 36field, 35field, 34field, 33field, 32field, 31field, 30field, 29field, 28field, 27field, 26field, 25field,
                 24field, 23field, 22field, 21field, 20field, 19field, 18field, 17field, 16field, 15field, 14field, 13field, 12field]];
    }

    inline empty_deck() -> [[field; 26]; 2] {
        return [[0field, 0field, 0field, 0field, 0field, 0field,0field, 0field, 0field, 0field, 0field, 0field, 0field,
                 0field, 0field, 0field, 0field, 0field, 0field, 0field, 0field, 0field, 0field, 0field, 0field, 0field], 
                [0field, 0field, 0field, 0field, 0field, 0field,0field, 0field, 0field, 0field, 0field, 0field, 0field,
                 0field, 0field, 0field, 0field, 0field, 0field, 0field, 0field, 0field, 0field, 0field, 0field, 0field]];
    }
}
