import sra_encryption_v0_0_1.leo;
import zk_deck_shuffle_v0_0_1.leo;

// The 'zk_texas_holdem' program.
program zk_texas_holdem.aleo {

    struct Players {
        player0: address,
        player1: address,
        player2: address,
        player3: address,
        player4: address,
        player5: address,
        player6: address,
        player7: address,
        player8: address,
    }

    struct GameState {
        active: bool,
        players: Players,
        phi: u128,
        n: u128,
    }

    record Player {
        owner: address,
        table_address: address,
        phi: u128, // Eulier's Totient Used to setup e, d, deck_e, deck_d
        n: u128,  // Semi Prime N used to setup e, d, deck_e, deck_d
        e: u128, // Public SRA key
        d: u128, // Private SRA key
        deck_e: [[u128; 26]; 2], // Individual Card Public SRA keys
        deck_d: [[u128; 26]; 2], // Individual Card Private SRA keys
    }

    record Card {
        owner: address,
        card: u128,
    }

    record Deck {
        owner: address,
        cards: [[u128; 26]; 2],
    }

    mapping game_state_map: address => GameState; // Is there some better key than address?

    transition get_address(target_address: u128) -> address {
        return target_address as address;
    }

    transition setup_game(players: Players, phi: u128, n: u128) -> Deck {
        let burn_address: address = 0u128 as address;
        let player0: address = players.player0;
        assert(player0 != burn_address);
        assert_eq(player0, self.caller);
        let player1: address = players.player1;
        let player2: address = players.player2;
        let player3: address = players.player3;
        let player4: address = players.player4;
        let player5: address = players.player5;
        let player6: address = players.player6;
        let player7: address = players.player7;
        let player8: address = players.player8;
        let p0: address = player0;
        let p1: address = burn_address;
        let p2: address = burn_address;
        let p3: address = burn_address;
        let p4: address = burn_address;
        let p5: address = burn_address;
        let p6: address = burn_address;
        let p7: address = burn_address;
        let p8: address = burn_address;
        if (player1 != burn_address) {
            p1 = player1;
        }
        if (player2 != burn_address) {
            p2 = player2;
        }
        if (player3 != burn_address) {
            p3 = player3;
        }
        if (player4 != burn_address) {
            p4 = player4;
        }
        if (player5 != burn_address) {
            p5 = player5;
        }
        if (player6 != burn_address) {
            p6 = player6;
        }
        if (player7 != burn_address) {
            p7 = player7;
        }
        if (player8 != burn_address) {
            p8 = player8;
        }

        let initiating_player: u128 = self.caller as u128;
        let updated_players: Players = Players {
            player0: p0,
            player1: p1,
            player2: p2,
            player3: p3,
            player4: p4,
            player5: p5,
            player6: p6,
            player7: p7,
            player8: p8,
        };
        return Deck {
            owner: self.caller,
            cards: initial_deck(),
        } then finalize (self.caller, updated_players, phi, n);
    }

    finalize setup_game(caller: address, players: Players, phi: u128, n: u128) {
        assert_eq(players.player0, caller);
        let updated_game_state: GameState = GameState {
            active: true,
            players,
            phi,
            n,
        };
        Mapping::set(game_state_map, caller, updated_game_state);
    }

    // e is the public SRA key generated by client, d is the private SRA key generated by client
    transition join_game(table_address: address, e: u128, d: u128, phi: u128, n: u128) -> Player {
        return Player {
            owner: self.caller,
            table_address,
            phi,
            n,
            e,
            d,
            deck_e: empty_deck(),
            deck_d: empty_deck(),
        } then finalize (table_address, self.caller);
    }

    finalize join_game(table_address: address, caller: address) {
        let game_state: GameState = Mapping::get(game_state_map, table_address);
        assert(game_state.active);
        let players: Players = game_state.players;
        let listed: bool = false;
        let burn_address: address = 0u128 as address;
        if (players.player0 == caller) {
            listed = true;
        } 
        if (players.player1 == caller) {
            listed = true;
        }
        if (players.player2 == caller) {
            listed = true;
        }
        if (players.player3 == caller) {
            listed = true;
        }
        if (players.player4 == caller) {
            listed = true;
        }
        if (players.player5 == caller) {
            listed = true;
        }
        if (players.player6 == caller) {
            listed = true;
        }
        if (players.player7 == caller) {
            listed = true;
        }
        if (players.player8 == caller) {
            listed = true;
        }
        assert(listed);
    }

    

    transition shuffle_and_pass(player: Player, deck: Deck, shuffles: [i8; 7], next_player: address) -> (Player, Deck) {
        let encrypted_deck: [[u128; 26]; 2] = sra_encryption.leo/encrypt_deck(player.e, player.n, deck.cards);
        let member_size: u8 = 128u8;
        let empty: [[u128; 26]; 2] = empty_deck();
        let tuple: (i8, [u128; 26], [u128; 26]) = (0i8, empty[0u8], empty[1u8]);
        for i: i8 in 0i8..7i8 {
            tuple: (i8, [u128; 26], [u128; 26]) = zk_deck_shuffle_v0_0_1.leo/setup_shuffle(shuffles[i as u8], encrypted_deck);
            encrypted_deck = zk_deck_shuffle_v0_0_1.leo/shuffle_deck(tuple.0, member_size, tuple.1, tuple.2);
        }
        return (Player {
            owner: player.owner,
            table_address: player.table_address,
            phi: player.phi,
            n: player.n,
            e: player.e,
            d: player.d,
            deck_e: player.deck_e,
            deck_d: player.deck_d,
        }, Deck {
            owner: next_player as address,
            cards: encrypted_deck,
        });
    }

    transition decrypt_encrypt_each_then_pass(player: Player, deck: Deck, deck_e: [[u128; 26]; 2], deck_d: [[u128; 26]; 2], next_player: address) -> (Player, Deck) {
        let e: u128 = player.e;
        let d: u128 = player.d;
        let n: u128 = player.n;
        let decrypted_deck: [[u128; 26]; 2] = sra_encryption.leo/decrypt_deck(d, n, deck.cards);
        let encrypted_deck: [[u128; 26]; 2] = sra_encryption.leo/encrypt_deck_per_card(deck_e, n, decrypted_deck);
        return (
            Player {
                owner: self.caller,
                table_address: player.table_address,
                phi: player.phi,
                n: player.n,
                e: player.e,
                d: player.d,
                deck_e: deck_e,
                deck_d: deck_d,
            },
            Deck {
                owner: next_player,
                cards: encrypted_deck,
            });
    }

    inline initial_deck() -> [[u128; 26]; 2] {
        return [[63u128, 62u128, 61u128, 60u128, 59u128, 58u128, 57u128, 56u128, 55u128, 54u128, 53u128, 52u128, 51u128,
                 50u128, 49u128, 48u128, 47u128, 46u128, 45u128, 44u128, 43u128, 42u128, 41u128, 40u128, 39u128, 38u128], 
                [37u128, 36u128, 35u128, 34u128, 33u128, 32u128, 31u128, 30u128, 29u128, 28u128, 27u128, 26u128, 25u128,
                 24u128, 23u128, 22u128, 21u128, 20u128, 19u128, 18u128, 17u128, 16u128, 15u128, 14u128, 13u128, 12u128]];
    }

    inline empty_deck() -> [[u128; 26]; 2] {
        return [[0u128, 0u128, 0u128, 0u128, 0u128, 0u128,0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128,
                 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128], 
                [0u128, 0u128, 0u128, 0u128, 0u128, 0u128,0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128,
                 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128, 0u128]];
    }
}
